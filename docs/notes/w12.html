<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture Note Week 12 – ETF2121/5912 - S2 2024</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="ETF2121/5912 - S2 2024 - Lecture Note Week 12">
<meta property="og:description" content="Homepage for ETF2121/5921 - Data Analysis in Business at Monash University, S2 2023.">
<meta property="og:site_name" content="ETF2121/5912 - S2 2024">
<meta name="twitter:title" content="ETF2121/5912 - S2 2024 - Lecture Note Week 12">
<meta name="twitter:description" content="Homepage for ETF2121/5921 - Data Analysis in Business at Monash University, S2 2023.">
<meta name="twitter:image" content="https://sta210-s22.github.io/website/notes/images/twitter-card.png">
<meta name="twitter:creator" content="@minebocek">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Lecture Note Week 12</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../images/logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Course information</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course-overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course-syllabus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Syllabus</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course-team.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teaching team</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Schedule</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Weekly Schedule</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../weeks/week-1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../weeks/week-2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-to" id="toc-introduction-to" class="nav-link active" data-scroll-target="#introduction-to">1. Introduction to</a></li>
  <li><a href="#static-holdout-method" id="toc-static-holdout-method" class="nav-link" data-scroll-target="#static-holdout-method">2. Static Holdout Method</a></li>
  <li><a href="#k-fold-cross-validation" id="toc-k-fold-cross-validation" class="nav-link" data-scroll-target="#k-fold-cross-validation">3. K-Fold Cross-Validation</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">4. Conclusion</a></li>
  <li><a href="#lecture-notes-computing-and-interpreting-performance-measures-for-classification-methods" id="toc-lecture-notes-computing-and-interpreting-performance-measures-for-classification-methods" class="nav-link" data-scroll-target="#lecture-notes-computing-and-interpreting-performance-measures-for-classification-methods">Lecture Notes: Computing and Interpreting Performance Measures for Classification Methods</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1. Introduction</a></li>
  <li><a href="#key-performance-measures" id="toc-key-performance-measures" class="nav-link" data-scroll-target="#key-performance-measures">2. Key Performance Measures</a></li>
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link" data-scroll-target="#implementation-in-r">3. Implementation in R</a></li>
  <li><a href="#interpretation" id="toc-interpretation" class="nav-link" data-scroll-target="#interpretation">4. Interpretation</a></li>
  <li><a href="#conclusion-1" id="toc-conclusion-1" class="nav-link" data-scroll-target="#conclusion-1">5. Conclusion</a></li>
  </ul></li>
  <li><a href="#logistic-regression" id="toc-logistic-regression" class="nav-link" data-scroll-target="#logistic-regression">Logistic Regression</a>
  <ul class="collapse">
  <li><a href="#introduction-1" id="toc-introduction-1" class="nav-link" data-scroll-target="#introduction-1">1. Introduction</a></li>
  <li><a href="#logistic-regression-model" id="toc-logistic-regression-model" class="nav-link" data-scroll-target="#logistic-regression-model">2. Logistic Regression Model</a></li>
  <li><a href="#applying-logistic-regression-in-r" id="toc-applying-logistic-regression-in-r" class="nav-link" data-scroll-target="#applying-logistic-regression-in-r">3. Applying Logistic Regression in R</a></li>
  <li><a href="#interpretation-1" id="toc-interpretation-1" class="nav-link" data-scroll-target="#interpretation-1">4. Interpretation</a></li>
  </ul></li>
  <li><a href="#fit-logistic-regression-model" id="toc-fit-logistic-regression-model" class="nav-link" data-scroll-target="#fit-logistic-regression-model">Fit logistic regression model</a></li>
  <li><a href="#summary-of-the-model" id="toc-summary-of-the-model" class="nav-link" data-scroll-target="#summary-of-the-model">Summary of the model</a></li>
  <li><a href="#predictions" id="toc-predictions" class="nav-link" data-scroll-target="#predictions">Predictions</a></li>
  <li><a href="#confusion-matrix-1" id="toc-confusion-matrix-1" class="nav-link" data-scroll-target="#confusion-matrix-1">Confusion matrix</a></li>
  <li><a href="#performance-metrics" id="toc-performance-metrics" class="nav-link" data-scroll-target="#performance-metrics">Performance metrics</a>
  <ul class="collapse">
  <li><a href="#conclusion-2" id="toc-conclusion-2" class="nav-link" data-scroll-target="#conclusion-2">6. Conclusion</a></li>
  <li><a href="#introduction-2" id="toc-introduction-2" class="nav-link" data-scroll-target="#introduction-2">. Introduction</a></li>
  <li><a href="#classification-tree-model" id="toc-classification-tree-model" class="nav-link" data-scroll-target="#classification-tree-model">2. Classification Tree Model</a></li>
  <li><a href="#applying-classification-trees-in-r" id="toc-applying-classification-trees-in-r" class="nav-link" data-scroll-target="#applying-classification-trees-in-r">3. Applying Classification Trees in R</a></li>
  <li><a href="#interpretation-2" id="toc-interpretation-2" class="nav-link" data-scroll-target="#interpretation-2">4. Interpretation</a></li>
  <li><a href="#example-from-business-analytics" id="toc-example-from-business-analytics" class="nav-link" data-scroll-target="#example-from-business-analytics">5. Example from “Business Analytics”</a></li>
  </ul></li>
  <li><a href="#fit-classification-tree" id="toc-fit-classification-tree" class="nav-link" data-scroll-target="#fit-classification-tree">Fit classification tree</a></li>
  <li><a href="#visualize-the-tree" id="toc-visualize-the-tree" class="nav-link" data-scroll-target="#visualize-the-tree">Visualize the tree</a></li>
  <li><a href="#predictions-1" id="toc-predictions-1" class="nav-link" data-scroll-target="#predictions-1">Predictions</a></li>
  <li><a href="#confusion-matrix-2" id="toc-confusion-matrix-2" class="nav-link" data-scroll-target="#confusion-matrix-2">Confusion matrix</a></li>
  <li><a href="#performance-metrics-1" id="toc-performance-metrics-1" class="nav-link" data-scroll-target="#performance-metrics-1">Performance metrics</a>
  <ul class="collapse">
  <li><a href="#conclusion-3" id="toc-conclusion-3" class="nav-link" data-scroll-target="#conclusion-3">6. Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture Note Week 12</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Learning Objective:</p>
<p>LO1: Evaluate out-of-sample predictive performance of a model.</p>
<p>LO2: Compute and interpret performance measures for classification methods.</p>
<p>LO3: Describe and apply logistic regression.</p>
<p>LO4: Describe and apply classification trees.</p>
</div>
</div>
<section id="introduction-to" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to">1. Introduction to</h3>
<p>Evaluating the out-of-sample predictive performance of a model is crucial in determining its generalizability to new, unseen data. Two common methods for this evaluation are the static holdout method and k-fold cross-validation. This lecture note will cover both methods, their implementation, advantages, and limitations.</p>
</section>
<section id="static-holdout-method" class="level3">
<h3 class="anchored" data-anchor-id="static-holdout-method">2. Static Holdout Method</h3>
<section id="concept" class="level4">
<h4 class="anchored" data-anchor-id="concept">2.1. Concept</h4>
<p>The static holdout method involves splitting the dataset into two distinct sets:</p>
<ul>
<li><p><strong>Training Set:</strong> Used to train the model.</p></li>
<li><p><strong>Testing (Holdout) Set:</strong> Used to evaluate the model’s performance on unseen data.</p></li>
</ul>
</section>
<section id="implementation" class="level4">
<h4 class="anchored" data-anchor-id="implementation">2.2. Implementation</h4>
<ol type="1">
<li><p><strong>Split the Dataset:</strong></p>
<ul>
<li>Typically, a common split ratio is 70-80% for training and 20-30% for testing.</li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code># Assuming data is in a data frame df and target variable is y set.seed(42) sample &lt;- sample.int(n = nrow(df), size = floor(.8*nrow(df)), replace = F) train &lt;- df[sample, ] test &lt;- df[-sample, ]</code></p></li>
<li><p><strong>Train the Model:</strong></p>
<ul>
<li>Fit the model on the training data.</li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code># Assuming using a linear model model &lt;- lm(y ~ ., data = train)</code></p></li>
<li><p><strong>Evaluate the Model:</strong></p>
<ul>
<li>Predict on the test data and evaluate performance.</li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>predictions &lt;- predict(model, newdata = test) actuals &lt;- test$y mse &lt;- mean((predictions - actuals)^2)  # Mean Squared Error</code></p></li>
</ol>
</section>
<section id="advantages-and-limitations" class="level4">
<h4 class="anchored" data-anchor-id="advantages-and-limitations">2.3. Advantages and Limitations</h4>
<ul>
<li><p><strong>Advantages:</strong></p>
<ul>
<li><p>Simple to implement and understand.</p></li>
<li><p>Computationally efficient.</p></li>
</ul></li>
<li><p><strong>Limitations:</strong></p>
<ul>
<li><p>Performance estimate can be highly dependent on the particular train-test split.</p></li>
<li><p>Not ideal for small datasets.</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="k-fold-cross-validation" class="level3">
<h3 class="anchored" data-anchor-id="k-fold-cross-validation">3. K-Fold Cross-Validation</h3>
<section id="concept-1" class="level4">
<h4 class="anchored" data-anchor-id="concept-1">3.1. Concept</h4>
<p>K-fold cross-validation involves splitting the dataset into <code>k</code> equally sized folds. The model is trained <code>k</code> times, each time using <code>k-1</code> folds for training and the remaining fold for testing. The average performance across all <code>k</code> iterations is then used as the final performance estimate.</p>
</section>
<section id="implementation-1" class="level4">
<h4 class="anchored" data-anchor-id="implementation-1">3.2. Implementation</h4>
<ol type="1">
<li><p><strong>Split the Dataset into K Folds:</strong></p>
<ul>
<li>Typically, <code>k</code> is set to 5 or 10.</li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(caret) set.seed(42) folds &lt;- createFolds(df$y, k = 5, list = TRUE)</code></p></li>
<li><p><strong>Train and Evaluate the Model:</strong></p>
<ul>
<li>Iterate over each fold, train the model on <code>k-1</code> folds and evaluate on the remaining fold.</li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`results &lt;- lapply(folds, function(fold) { train &lt;- df[-fold, ] test &lt;- df[fold, ]</p>
<p>model &lt;- lm(y ~ ., data = train) predictions &lt;- predict(model, newdata = test) actuals &lt;- test$y mse &lt;- mean((predictions - actuals)^2) return(mse) })</p>
<p>mean_mse &lt;- mean(unlist(results)) # Average Mean Squared Error`</p></li>
</ol>
</section>
<section id="advantages-and-limitations-1" class="level4">
<h4 class="anchored" data-anchor-id="advantages-and-limitations-1">3.3. Advantages and Limitations</h4>
<ul>
<li><p><strong>Advantages:</strong></p>
<ul>
<li><p>More reliable performance estimate as it reduces variability due to data splitting.</p></li>
<li><p>Utilizes the entire dataset for both training and testing, ensuring no data is wasted.</p></li>
</ul></li>
<li><p><strong>Limitations:</strong></p>
<ul>
<li><p>More computationally intensive due to multiple training iterations.</p></li>
<li><p>Not as simple as the static holdout method.</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">4. Conclusion</h3>
<p>Both the static holdout method and k-fold cross-validation are essential tools for evaluating the out-of-sample predictive performance of a model. The static holdout method is simpler and faster, suitable for large datasets. In contrast, k-fold cross-validation provides a more robust performance estimate, especially valuable for small to medium-sized datasets. Understanding and correctly implementing these methods will enhance the reliability of your model’s performance assessment.</p>
</section>
<section id="lecture-notes-computing-and-interpreting-performance-measures-for-classification-methods" class="level2">
<h2 class="anchored" data-anchor-id="lecture-notes-computing-and-interpreting-performance-measures-for-classification-methods">Lecture Notes: Computing and Interpreting Performance Measures for Classification Methods</h2>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">1. Introduction</h3>
<p>Evaluating the performance of classification models is crucial for understanding their effectiveness in predicting categorical outcomes. This lecture note covers key performance measures, their computation, and interpretation for classification methods.</p>
</section>
<section id="key-performance-measures" class="level3">
<h3 class="anchored" data-anchor-id="key-performance-measures">2. Key Performance Measures</h3>
<section id="confusion-matrix" class="level4">
<h4 class="anchored" data-anchor-id="confusion-matrix">2.1. Confusion Matrix</h4>
<p>A confusion matrix is a table that summarizes the performance of a classification model by comparing the actual and predicted classifications.</p>
<ul>
<li><p><strong>True Positive (TP):</strong> Correctly predicted positive cases.</p></li>
<li><p><strong>True Negative (TN):</strong> Correctly predicted negative cases.</p></li>
<li><p><strong>False Positive (FP):</strong> Incorrectly predicted positive cases (Type I error).</p></li>
<li><p><strong>False Negative (FN):</strong> Incorrectly predicted negative cases (Type II error).</p></li>
</ul>
</section>
<section id="accuracy" class="level4">
<h4 class="anchored" data-anchor-id="accuracy">2.2. Accuracy</h4>
<p>Accuracy measures the proportion of correct predictions (both true positives and true negatives) among the total number of cases.</p>
<p>Accuracy=TP+TNTP+TN+FP+FN = Accuracy=TP+TN+FP+FNTP+TN​</p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN)</code></p>
</section>
<section id="precision" class="level4">
<h4 class="anchored" data-anchor-id="precision">2.3. Precision</h4>
<p>Precision (also called Positive Predictive Value) measures the proportion of true positive predictions among all positive predictions.</p>
<p>Precision=TPTP+FP = Precision=TP+FPTP​</p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>precision &lt;- TP / (TP + FP)</code></p>
</section>
<section id="recall" class="level4">
<h4 class="anchored" data-anchor-id="recall">2.4. Recall</h4>
<p>Recall (also called Sensitivity or True Positive Rate) measures the proportion of true positive cases among all actual positive cases.</p>
<p>Recall=TPTP+FN = Recall=TP+FNTP​</p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>recall &lt;- TP / (TP + FN)</code></p>
</section>
<section id="f1-score" class="level4">
<h4 class="anchored" data-anchor-id="f1-score">2.5. F1 Score</h4>
<p>The F1 Score is the harmonic mean of precision and recall, providing a balance between the two.</p>
<p>F1&nbsp;Score=2⋅Precision⋅RecallPrecision+Recall = 2 F1&nbsp;Score=2⋅Precision+RecallPrecision⋅Recall​</p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>f1_score &lt;- 2 * (precision * recall) / (precision + recall)</code></p>
</section>
<section id="specificity" class="level4">
<h4 class="anchored" data-anchor-id="specificity">2.6. Specificity</h4>
<p>Specificity (also called True Negative Rate) measures the proportion of true negative cases among all actual negative cases.</p>
<p>Specificity=TNTN+FP = Specificity=TN+FPTN​</p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>specificity &lt;- TN / (TN + FP)</code></p>
</section>
</section>
<section id="implementation-in-r" class="level3">
<h3 class="anchored" data-anchor-id="implementation-in-r">3. Implementation in R</h3>
<p>Assuming you have a binary classification model and a dataset with actual and predicted values, here’s how to compute these performance measures in R.</p>
<ol type="1">
<li><p><strong>Generate Predictions:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code># Example using a logistic regression model model &lt;- glm(y ~ ., data = train, family = binomial) predictions &lt;- predict(model, newdata = test, type = "response") predicted_classes &lt;- ifelse(predictions &gt; 0.5, 1, 0)</code></p></li>
<li><p><strong>Create a Confusion Matrix:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(caret) confusion_matrix &lt;- confusionMatrix(as.factor(predicted_classes), as.factor(test$y))</code></p></li>
<li><p><strong>Extract Performance Measures:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`confusion &lt;- confusion_matrix$table TP &lt;- confusion[2, 2] TN &lt;- confusion[1, 1] FP &lt;- confusion[1, 2] FN &lt;- confusion[2, 1]</p>
<p>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN) precision &lt;- TP / (TP + FP) recall &lt;- TP / (TP + FN) f1_score &lt;- 2 * (precision * recall) / (precision + recall) specificity &lt;- TN / (TN + FP)`</p></li>
</ol>
</section>
<section id="interpretation" class="level3">
<h3 class="anchored" data-anchor-id="interpretation">4. Interpretation</h3>
<ul>
<li><p><strong>Accuracy:</strong> High accuracy indicates that the model correctly classifies most cases. However, it may be misleading if the classes are imbalanced.</p></li>
<li><p><strong>Precision:</strong> High precision means that when the model predicts a positive case, it is usually correct. It is important when the cost of false positives is high.</p></li>
<li><p><strong>Recall:</strong> High recall means that the model can identify most actual positive cases. It is important when the cost of false negatives is high.</p></li>
<li><p><strong>F1 Score:</strong> A balanced measure that is useful when you need to balance precision and recall.</p></li>
<li><p><strong>Specificity:</strong> High specificity means that the model can identify most actual negative cases. It is important when the cost of false positives is high.</p></li>
</ul>
</section>
<section id="conclusion-1" class="level3">
<h3 class="anchored" data-anchor-id="conclusion-1">5. Conclusion</h3>
<p>Understanding and correctly interpreting performance measures are essential for evaluating the effectiveness of classification models. Each measure provides unique insights, and the choice of which to prioritize depends on the specific context and costs associated with false positives and false negatives.</p>
</section>
</section>
<section id="logistic-regression" class="level2">
<h2 class="anchored" data-anchor-id="logistic-regression">Logistic Regression</h2>
<section id="introduction-1" class="level3">
<h3 class="anchored" data-anchor-id="introduction-1">1. Introduction</h3>
<p>Logistic regression is a powerful statistical method used for binary classification problems. It is widely applied to scenarios where the outcome variable is binary (e.g., yes/no, success/failure). This lecture note will describe the logistic regression model and demonstrate its application using examples inspired by the “Business Analytics” book by Jeffrey D. Camm and others.</p>
</section>
<section id="logistic-regression-model" class="level3">
<h3 class="anchored" data-anchor-id="logistic-regression-model">2. Logistic Regression Model</h3>
<section id="concept-2" class="level4">
<h4 class="anchored" data-anchor-id="concept-2">2.1. Concept</h4>
<p>Logistic regression models the probability of a binary outcome using a logistic function. Unlike linear regression, which predicts continuous outcomes, logistic regression predicts the probability that a given input point belongs to a particular class.</p>
<p>The logistic function (also known as the sigmoid function) is defined as:</p>
<p>P(Y=1∣X)=11+e−(β0+β1X1+β2X2+…+βkXk)P(Y=1|X) = P(Y=1∣X)=1+e−(β0​+β1​X1​+β2​X2​+…+βk​Xk​)1​</p>
<p>Where:</p>
<ul>
<li><p>P(Y=1∣X)P(Y=1|X)P(Y=1∣X) is the probability that the outcome YYY is 1 given the input XXX.</p></li>
<li><p>β0,β1,…,βk_0, _1, , _kβ0​,β1​,…,βk​ are the coefficients of the model.</p></li>
</ul>
</section>
<section id="odds-and-logit" class="level4">
<h4 class="anchored" data-anchor-id="odds-and-logit">2.2. Odds and Logit</h4>
<ul>
<li><strong>Odds:</strong> The odds of an event are the ratio of the probability of the event occurring to the probability of it not occurring.</li>
</ul>
<p>Odds=P(Y=1∣X)1−P(Y=1∣X) = Odds=1−P(Y=1∣X)P(Y=1∣X)​</p>
<ul>
<li><strong>Logit:</strong> The logit function is the natural logarithm of the odds.</li>
</ul>
<p>Logit(P)=log⁡(P1−P)=β0+β1X1+β2X2+…+βkXk(P) = () = _0 + _1X_1 + _2X_2 + + _kX_kLogit(P)=log(1−PP​)=β0​+β1​X1​+β2​X2​+…+βk​Xk​</p>
</section>
</section>
<section id="applying-logistic-regression-in-r" class="level3">
<h3 class="anchored" data-anchor-id="applying-logistic-regression-in-r">3. Applying Logistic Regression in R</h3>
<section id="data-preparation" class="level4">
<h4 class="anchored" data-anchor-id="data-preparation">3.1. Data Preparation</h4>
<ol type="1">
<li><p><strong>Load the Data:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code># Example dataset data &lt;- read.csv("path_to_dataset.csv")</code></p></li>
<li><p><strong>Split the Data into Training and Testing Sets:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>set.seed(123) sample &lt;- sample.int(n = nrow(data), size = floor(0.8*nrow(data)), replace = FALSE) train &lt;- data[sample, ] test &lt;- data[-sample, ]</code></p></li>
</ol>
</section>
<section id="model-training" class="level4">
<h4 class="anchored" data-anchor-id="model-training">3.2. Model Training</h4>
<ol type="1">
<li><p><strong>Fit the Logistic Regression Model:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>model &lt;- glm(binary_outcome ~ ., data = train, family = binomial)</code></p></li>
<li><p><strong>View Model Summary:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>summary(model)</code></p></li>
</ol>
</section>
<section id="model-evaluation" class="level4">
<h4 class="anchored" data-anchor-id="model-evaluation">3.3. Model Evaluation</h4>
<ol type="1">
<li><p><strong>Make Predictions:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>predictions &lt;- predict(model, newdata = test, type = "response") predicted_classes &lt;- ifelse(predictions &gt; 0.5, 1, 0)</code></p></li>
<li><p><strong>Create a Confusion Matrix:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(caret) confusion_matrix &lt;- confusionMatrix(as.factor(predicted_classes), as.factor(test$binary_outcome)) print(confusion_matrix)</code></p></li>
<li><p><strong>Calculate Performance Metrics:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`confusion &lt;- confusion_matrix$table TP &lt;- confusion[2, 2] TN &lt;- confusion[1, 1] FP &lt;- confusion[1, 2] FN &lt;- confusion[2, 1]</p>
<p>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN) precision &lt;- TP / (TP + FP) recall &lt;- TP / (TP + FN) f1_score &lt;- 2 * (precision * recall) / (precision + recall) specificity &lt;- TN / (TN + FP)</p>
<p>cat(“Accuracy:”, accuracy, “”) cat(“Precision:”, precision, “”) cat(“Recall:”, recall, “”) cat(“F1 Score:”, f1_score, “”) cat(“Specificity:”, specificity, “”)`</p></li>
</ol>
</section>
</section>
<section id="interpretation-1" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-1">4. Interpretation</h3>
<ul>
<li><p><strong>Coefficients:</strong> The coefficients (β values) in the logistic regression model indicate the change in the log odds of the outcome for a one-unit increase in the predictor variable.</p></li>
<li><p><strong>Odds Ratio:</strong> The exponentiated coefficients (e^β) represent the odds ratio, showing how the odds of the outcome change with a one-unit increase in the predictor.</p></li>
<li><p><strong>Performance Metrics:</strong> The confusion matrix and derived metrics (accuracy, precision, recall, F1 score, specificity) help evaluate the model’s performance on the test data.</p></li>
</ul>
<section id="example-scenario-predicting-customer-churn" class="level4">
<h4 class="anchored" data-anchor-id="example-scenario-predicting-customer-churn">5.1. Example Scenario: Predicting Customer Churn</h4>
<ul>
<li><p><strong>Dataset:</strong> Customer data with features like age, account length, service usage, etc.</p></li>
<li><p><strong>Binary Outcome:</strong> Whether the customer churned (1) or not (0).</p></li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`# Example code based on a hypothetical dataset data &lt;- read.csv(“customer_churn.csv”) set.seed(123) sample &lt;- sample.int(n = nrow(data), size = floor(0.8*nrow(data)), replace = FALSE) train &lt;- data[sample, ] test &lt;- data[-sample, ]</p>
</section>
</section>
</section>
<section id="fit-logistic-regression-model" class="level1">
<h1>Fit logistic regression model</h1>
<p>model &lt;- glm(churn ~ age + account_length + service_usage, data = train, family = binomial)</p>
</section>
<section id="summary-of-the-model" class="level1">
<h1>Summary of the model</h1>
<p>summary(model)</p>
</section>
<section id="predictions" class="level1">
<h1>Predictions</h1>
<p>predictions &lt;- predict(model, newdata = test, type = “response”) predicted_classes &lt;- ifelse(predictions &gt; 0.5, 1, 0)</p>
</section>
<section id="confusion-matrix-1" class="level1">
<h1>Confusion matrix</h1>
<p>library(caret) confusion_matrix &lt;- confusionMatrix(as.factor(predicted_classes), as.factor(test$churn)) print(confusion_matrix)</p>
</section>
<section id="performance-metrics" class="level1">
<h1>Performance metrics</h1>
<p>confusion &lt;- confusion_matrix$table TP &lt;- confusion[2, 2] TN &lt;- confusion[1, 1] FP &lt;- confusion[1, 2] FN &lt;- confusion[2, 1]</p>
<p>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN) precision &lt;- TP / (TP + FP) recall &lt;- TP / (TP + FN) f1_score &lt;- 2 * (precision * recall) / (precision + recall) specificity &lt;- TN / (TN + FP)</p>
<p>cat(“Accuracy:”, accuracy, “”) cat(“Precision:”, precision, “”) cat(“Recall:”, recall, “”) cat(“F1 Score:”, f1_score, “”) cat(“Specificity:”, specificity, “”)`</p>
<section id="conclusion-2" class="level3">
<h3 class="anchored" data-anchor-id="conclusion-2">6. Conclusion</h3>
<p>Logistic regression is a fundamental tool for binary classification problems. Understanding how to apply and interpret logistic regression models is essential for making informed business decisions. By using the examples and techniques from the “Business Analytics” book, you can effectively implement logistic regression in your data analysis projects.</p>
</section>
<section id="introduction-2" class="level3">
<h3 class="anchored" data-anchor-id="introduction-2">. Introduction</h3>
<p>A classification tree is a decision tree that is used to classify observations into categories. It is a non-parametric method that splits the data into subsets based on the value of input features, leading to a tree structure where each node represents a decision rule and each leaf represents a class label. This lecture note will describe the classification tree model and demonstrate its application using examples inspired by the “Business Analytics” book by Jeffrey D. Camm and others.</p>
</section>
<section id="classification-tree-model" class="level3">
<h3 class="anchored" data-anchor-id="classification-tree-model">2. Classification Tree Model</h3>
<section id="concept-3" class="level4">
<h4 class="anchored" data-anchor-id="concept-3">2.1. Concept</h4>
<p>A classification tree is built by recursively partitioning the dataset into subsets based on the value of input features. The objective is to create subsets that are as homogeneous as possible concerning the target variable.</p>
</section>
<section id="tree-structure" class="level4">
<h4 class="anchored" data-anchor-id="tree-structure">2.2. Tree Structure</h4>
<ul>
<li><p><strong>Root Node:</strong> The topmost node representing the entire dataset.</p></li>
<li><p><strong>Internal Nodes:</strong> Nodes that split into further nodes based on a decision rule.</p></li>
<li><p><strong>Leaf Nodes:</strong> Terminal nodes that represent the final class label.</p></li>
</ul>
</section>
<section id="splitting-criteria" class="level4">
<h4 class="anchored" data-anchor-id="splitting-criteria">2.3. Splitting Criteria</h4>
<p>Common criteria for splitting nodes include:</p>
<ul>
<li><p><strong>Gini Index:</strong> Measures impurity. Lower values indicate more homogeneous nodes.</p></li>
<li><p><strong>Entropy:</strong> Measures disorder. Lower values indicate more homogeneous nodes.</p></li>
<li><p><strong>Misclassification Error:</strong> Measures the frequency of incorrect classifications.</p></li>
</ul>
</section>
</section>
<section id="applying-classification-trees-in-r" class="level3">
<h3 class="anchored" data-anchor-id="applying-classification-trees-in-r">3. Applying Classification Trees in R</h3>
<section id="data-preparation-1" class="level4">
<h4 class="anchored" data-anchor-id="data-preparation-1">3.1. Data Preparation</h4>
<ol type="1">
<li><p><strong>Load the Data:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code># Example dataset data &lt;- read.csv("path_to_dataset.csv")</code></p></li>
<li><p><strong>Split the Data into Training and Testing Sets:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>set.seed(123) sample &lt;- sample.int(n = nrow(data), size = floor(0.8*nrow(data)), replace = FALSE) train &lt;- data[sample, ] test &lt;- data[-sample, ]</code></p></li>
</ol>
</section>
<section id="model-training-1" class="level4">
<h4 class="anchored" data-anchor-id="model-training-1">3.2. Model Training</h4>
<ol type="1">
<li><p><strong>Fit the Classification Tree:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(rpart) model &lt;- rpart(binary_outcome ~ ., data = train, method = "class")</code></p></li>
<li><p><strong>View the Tree:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(rpart.plot) rpart.plot(model)</code></p></li>
</ol>
</section>
<section id="model-evaluation-1" class="level4">
<h4 class="anchored" data-anchor-id="model-evaluation-1">3.3. Model Evaluation</h4>
<ol type="1">
<li><p><strong>Make Predictions:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>predictions &lt;- predict(model, newdata = test, type = "class")</code></p></li>
<li><p><strong>Create a Confusion Matrix:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p><code>library(caret) confusion_matrix &lt;- confusionMatrix(predictions, as.factor(test$binary_outcome)) print(confusion_matrix)</code></p></li>
<li><p><strong>Calculate Performance Metrics:</strong></p>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`confusion &lt;- confusion_matrix$table TP &lt;- confusion[2, 2] TN &lt;- confusion[1, 1] FP &lt;- confusion[1, 2] FN &lt;- confusion[2, 1]</p>
<p>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN) precision &lt;- TP / (TP + FP) recall &lt;- TP / (TP + FN) f1_score &lt;- 2 * (precision * recall) / (precision + recall) specificity &lt;- TN / (TN + FP)</p>
<p>cat(“Accuracy:”, accuracy, “”) cat(“Precision:”, precision, “”) cat(“Recall:”, recall, “”) cat(“F1 Score:”, f1_score, “”) cat(“Specificity:”, specificity, “”)`</p></li>
</ol>
</section>
</section>
<section id="interpretation-2" class="level3">
<h3 class="anchored" data-anchor-id="interpretation-2">4. Interpretation</h3>
<ul>
<li><p><strong>Tree Structure:</strong> The tree diagram provides a visual representation of the decision rules used to classify observations.</p></li>
<li><p><strong>Decision Rules:</strong> Each internal node represents a decision rule based on a feature and a threshold value.</p></li>
<li><p><strong>Performance Metrics:</strong> The confusion matrix and derived metrics (accuracy, precision, recall, F1 score, specificity) help evaluate the model’s performance on the test data.</p></li>
</ul>
</section>
<section id="example-from-business-analytics" class="level3">
<h3 class="anchored" data-anchor-id="example-from-business-analytics">5. Example from “Business Analytics”</h3>
<p>In “Business Analytics” by Jeffrey D. Camm and others, classification trees are often applied to real-world business problems, such as customer segmentation, fraud detection, or risk assessment.</p>
<section id="example-scenario-predicting-customer-churn-1" class="level4">
<h4 class="anchored" data-anchor-id="example-scenario-predicting-customer-churn-1">5.1. Example Scenario: Predicting Customer Churn</h4>
<ul>
<li><p><strong>Dataset:</strong> Customer data with features like age, account length, service usage, etc.</p></li>
<li><p><strong>Binary Outcome:</strong> Whether the customer churned (1) or not (0).</p></li>
</ul>
<pre><code>r</code></pre>
<p>Copy code</p>
<p>`# Example code based on a hypothetical dataset data &lt;- read.csv(“customer_churn.csv”) set.seed(123) sample &lt;- sample.int(n = nrow(data), size = floor(0.8*nrow(data)), replace = FALSE) train &lt;- data[sample, ] test &lt;- data[-sample, ]</p>
</section>
</section>
</section>
<section id="fit-classification-tree" class="level1">
<h1>Fit classification tree</h1>
<p>library(rpart) model &lt;- rpart(churn ~ age + account_length + service_usage, data = train, method = “class”)</p>
</section>
<section id="visualize-the-tree" class="level1">
<h1>Visualize the tree</h1>
<p>library(rpart.plot) rpart.plot(model)</p>
</section>
<section id="predictions-1" class="level1">
<h1>Predictions</h1>
<p>predictions &lt;- predict(model, newdata = test, type = “class”)</p>
</section>
<section id="confusion-matrix-2" class="level1">
<h1>Confusion matrix</h1>
<p>library(caret) confusion_matrix &lt;- confusionMatrix(predictions, as.factor(test$churn)) print(confusion_matrix)</p>
</section>
<section id="performance-metrics-1" class="level1">
<h1>Performance metrics</h1>
<p>confusion &lt;- confusion_matrix$table TP &lt;- confusion[2, 2] TN &lt;- confusion[1, 1] FP &lt;- confusion[1, 2] FN &lt;- confusion[2, 1]</p>
<p>accuracy &lt;- (TP + TN) / (TP + TN + FP + FN) precision &lt;- TP / (TP + FP) recall &lt;- TP / (TP + FN) f1_score &lt;- 2 * (precision * recall) / (precision + recall) specificity &lt;- TN / (TN + FP)</p>
<p>cat(“Accuracy:”, accuracy, “”) cat(“Precision:”, precision, “”) cat(“Recall:”, recall, “”) cat(“F1 Score:”, f1_score, “”) cat(“Specificity:”, specificity, “”)`</p>
<section id="conclusion-3" class="level3">
<h3 class="anchored" data-anchor-id="conclusion-3">6. Conclusion</h3>
<p>Classification trees are intuitive and powerful tools for binary classification problems. They provide a clear visual representation of decision rules, making them easy to interpret.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sta210-s22\.github\.io\/website\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Dr.&nbsp;Joan Tan</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This page is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>