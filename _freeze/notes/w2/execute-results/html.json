{
  "hash": "40bd906bd06315e80556b18e3aa6fb7c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lecture Note Week 2\"\nfilters: \n  - webr\nexecute: \n  echo: false\n---\n\n\n\n::: callout-note\nLearning Objective:\n\nLO1: Able to write SQL queries to retrieve data from a database\n\nLO2: Able to write SQL queries to manipulate data in a database\n\nLO3: Understand basic SQL syntax\n:::\n\n\n\n\n\n\n\n# SQL\n\n### Case sensitive? ðŸ‹ï¸\n\nIn SQL, case sensitivity largely depends on the specific database system and Operating System and its configuration. By default, SQL keywords (such as `SELECT`, `FROM`, `WHERE`) are case-insensitive across most SQL databases, including Oracle, MySQL, and SQL Server. This means you can write these keywords in uppercase, lowercase, or a mix of both without affecting the query's execution. However, the case sensitivity of data within the tables, such as column names and string values, can vary.\n\nFor example, in Oracle SQL, string values are case-sensitive by default unless explicitly specified otherwise. This implies that a query differentiating between 'Smith' and 'smith' in a string comparison would yield different results. It is essential to be aware of your specific database system's behavior regarding case sensitivity, and when necessary, functions like `UPPER()` or `LOWER()` can be used to ensure consistent case handling in string comparisons.\n\nSo, let's stick to Oracle SQL (the most common database in corporate world) at this moment. In summary,\n\n1.  column name is not case-sensitive\n2.  SQL keywords are not case-sensitive\n3.  character or string values are case-sensitive.\n\n### HR Schema Overview\n\nThe HR schema typically includes the following tables:\n\n-   `EMPLOYEES`\n\n-   `DEPARTMENTS`\n\n-   `JOBS`\n\n-   `JOB_HISTORY`\n\n-   `LOCATIONS`\n\n-   `COUNTRIES`\n\n-   `REGIONS`\n\nThe following examples will be using this `HR` schema.\n\n![](images/schema.gif)\n\n### SELECT Statement\n\nThe `SELECT` statement retrieves data from the database.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ...\nFROM table_name;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name\nFROM hr.employees;\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table.\n\n[Please remember that `hr.` is the schema name.]{style=\"color:red;\"} ðŸ‘ˆ\n\n### DISTINCT Keyword\n\nThe `DISTINCT` keyword returns only distinct values.\n\n**Syntax:**\n\n``` sql\nSELECT DISTINCT column1, column2, ...\nFROM table_name;\n```\n\n**Example:**\n\n``` sql\nSELECT DISTINCT department_id\nFROM hr.employees;\n```\n\nThis query retrieves unique `department_id` values from the `EMPLOYEES` table.\n\n### ORDER BY Clause\n\nThe `ORDER BY` clause sorts the result set in either ascending or descending order.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nORDER BY last_name ASC;\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table and sorts the results by `last_name` in ascending order.\n\n### LIMIT Clause\n\nIn Oracle SQL, the `FETCH FIRST` clause limits the number of rows returned by a query.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nORDER BY column1 [ASC|DESC] \nFETCH FIRST number ROWS ONLY;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nORDER BY last_name ASC \nFETCH FIRST 10 ROWS ONLY;\n```\n\nThis query retrieves the first 10 rows from the `EMPLOYEES` table, sorted by `last_name` in ascending order.\n\n### COUNT Function\n\nThe `COUNT` function returns the number of rows that matches a specified condition.\n\n**Syntax:**\n\n``` sql\nSELECT COUNT(column_name) \nFROM table_name WHERE condition;\n```\n\n**Example:**\n\n``` sql\nSELECT COUNT(employee_id) FROM employees WHERE department_id = 50;\n```\n\nThis query counts the number of employees in department 50.\n\n### WHERE Clause\n\nThe `WHERE` clause filters records.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nWHERE condition;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nWHERE department_id = 50;\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where `department_id` is 50.\n\n### LIKE Operator\n\nThe `LIKE` operator searches for a specified pattern in a column.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nWHERE columnn LIKE pattern;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nWHERE first_name LIKE 'A%';\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where the `first_name` starts with 'A'.\n\n### IN Operator\n\nThe `IN` operator allows specifying multiple values in a `WHERE` clause.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nWHERE columnN IN (value1, value2, ...);\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nWHERE department_id IN (10, 20, 30);\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where the `department_id` is either 10, 20, or 30.\n\n### ILIKE Operator\n\nOracle SQL does not have an `ILIKE` operator, but for case-insensitive searches, use the `LOWER` or `UPPER` functions with `LIKE`.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nWHERE LOWER(columnN) LIKE LOWER(pattern);\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nWHERE LOWER(first_name) LIKE 'a%';\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where the `first_name` starts with 'a' or 'A'.\n\n### Logical Operators\n\nLogical operators combine multiple conditions in a `WHERE` clause. Common logical operators include `AND`, `OR`, and `NOT`.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ... \nFROM table_name \nWHERE condition1 AND condition2;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name \nFROM employees \nWHERE department_id = 50 AND salary > 5000;\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where the `department_id` is 50 and the `salary` is greater than 5000.\n\n### Aggregation Functions\n\nAggregation functions perform a calculation on a set of values and return a single value. Common aggregation functions include `COUNT`, `SUM`, and `AVG`.\n\n#### COUNT Function\n\n**Syntax:**\n\n``` sql\nELECT COUNT(column_name) \nFROM table_name \nWHERE condition;\n```\n\n**Example:**\n\n``` sql\nSELECT COUNT(employee_id) \nFROM employees \nWHERE department_id = 50;\n```\n\nThis query counts the number of employees in department 50.\n\n#### SUM Function\n\nThe `SUM` function returns the total sum of a numeric column.\n\n**Syntax:**\n\n``` sql\nSELECT SUM(column_name) \nFROM table_name \nWHERE condition;\n```\n\n**Example:**\n\n``` sql\nSELECT SUM(salary) \nFROM employees \nWHERE department_id = 50;\n```\n\nThis query calculates the total salary of employees in department 50.\n\n#### AVG Function\n\nThe `AVG` function returns the average value of a numeric column.\n\n**Syntax:**\n\n``` sql\nSELECT AVG(column_name) \nFROM table_name \nWHERE condition;\n```\n\n**Example:**\n\n``` sql\nSELECT AVG(salary) \nFROM employees \nWHERE department_id = 50;\n```\n\nThis query calculates the average salary of employees in department 50.\n\n#### BETWEEN Operator\n\nThe `BETWEEN` operator selects values within a specified range.\n\n**Syntax:**\n\n``` sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE columnN BETWEEN value1 AND value2;\n```\n\n**Example:**\n\n``` sql\nSELECT first_name, last_name\nFROM employees\nWHERE salary BETWEEN 5000 AND 10000;\n```\n\nThis query retrieves the `first_name` and `last_name` columns from the `EMPLOYEES` table where the `salary` is between 5000 and 10000.\n\n### GROUP BY Clause\n\nThe `GROUP BY` clause groups rows that have the same values in specified columns into aggregate data.\n\n**Syntax:**\n\n``` sql\nSELECT column1, aggregate_function(column2) \nFROM table_name \nWHERE condition \nGROUP BY column1;\n```\n\n**Example:**\n\n``` sql\nSELECT department_id, COUNT(employee_id) \nFROM employees \nGROUP BY department_id;\n```\n\nThis query counts the number of employees in each department.\n\n### HAVING Clause\n\nThe `HAVING` clause filters groups based on a specified condition.\n\n**Syntax:**\n\n``` sql\nSELECT column1, aggregate_function(column2) \nFROM table_name \nWHERE condition \nGROUP BY column1 \nHAVING condition;\n```\n\n**Example:**\n\n``` sql\nSELECT department_id, COUNT(employee_id) \nFROM employees \nGROUP BY department_id \nHAVING COUNT(employee_id) > 5;\n```\n\nThis query counts the number of employees in each department but only returns departments with more than 5 employees.\n\n## Table Join\n\nTable joins in SQL allow you to combine rows from two or more tables based on a related column between them. Joins are essential for querying data that is spread across multiple tables in a relational database. The HR schema from Oracle provides a good basis for understanding joins, as it contains several related tables such as `EMPLOYEES`, `DEPARTMENTS`, `JOBS`, `JOB_HISTORY`, `LOCATIONS`, `COUNTRIES`, and `REGIONS`.\n\n### Types of Joins\n\n1.  **INNER JOIN**\n\n2.  **LEFT JOIN (LEFT OUTER JOIN)**\n\n3.  **RIGHT JOIN (RIGHT OUTER JOIN)**\n\n4.  **FULL OUTER JOIN**\n\n5.  **CROSS JOIN**\n\n6.  **SELF JOIN**\n\n![](images/clipboard-3618812221.png)\n\n![source: Jitendra Kumar's LinkedIn](images/clipboard-1865905490.png){width=\"300\"}\n\n#### 1. INNER JOIN\n\nAn `INNER JOIN` returns records that have matching values in both tables.\n\n**Syntax:**\n\n``` sql\nSELECT columns\nFROM table1\nINNER JOIN table2 ON table1.common_column = table2.common_column;`\n```\n\n**Example:** Retrieve employees along with their department names.\n\n``` sql\nSELECT e.first_name, e.last_name, d.department_name\nFROM employees e\nINNER JOIN departments d ON e.department_id = d.department_id;\n```\n\nThis query joins the `EMPLOYEES` table with the `DEPARTMENTS` table on the `department_id` column, returning only the rows with matching `department_id` values.\n\n#### 2. LEFT JOIN (LEFT OUTER JOIN)\n\nA `LEFT JOIN` returns all records from the left table (table1), and the matched records from the right table (table2). If no match is found, NULL values are returned for columns from the right table.\n\n**Syntax:**\n\n``` sql\nSELECT columns\nFROM table1\nLEFT JOIN table2 ON table1.common_column = table2.common_column;\n```\n\n**Example:** Retrieve all departments and their employees, including departments without employees.\n\n``` sql\nSELECT d.department_name, e.first_name, e.last_name\nFROM departments d\nLEFT JOIN employees e ON d.department_id = e.department_id;\n```\n\nThis query joins the `DEPARTMENTS` table with the `EMPLOYEES` table, including all departments even if they have no employees.\n\n#### 3. RIGHT JOIN (RIGHT OUTER JOIN)\n\nA `RIGHT JOIN` returns all records from the right table (table2), and the matched records from the left table (table1). If no match is found, NULL values are returned for columns from the left table.\n\n**Syntax:**\n\n``` sql\nSELECT columns\nFROM table1\nRIGHT JOIN table2 ON table1.common_column = table2.common_column;\n```\n\n**Example:** Retrieve all employees and their department names, including employees without a department.\n\n``` sql\nSELECT e.first_name, e.last_name, d.department_name\nFROM employees e\nRIGHT JOIN departments d ON e.department_id = d.department_id;\n```\n\nThis query joins the `EMPLOYEES` table with the `DEPARTMENTS` table, including all employees even if they don't belong to a department.\n\n#### 4. FULL OUTER JOIN\n\nA `FULL OUTER JOIN` returns all records when there is a match in either left (table1) or right (table2) table records. If there is no match, NULL values are returned for the non-matching side.\n\n**Syntax:**\n\n``` sql\nSELECT columns\nFROM table1\nFULL OUTER JOIN table2 ON table1.common_column = table2.common_column;\n```\n\n**Example:** Retrieve all departments and their employees, including departments without employees and employees without departments.\n\n``` sql\nSELECT d.department_name, e.first_name, e.last_name\nFROM departments d\nFULL OUTER JOIN employees e ON d.department_id = e.department_id;\n```\n\nThis query joins the `DEPARTMENTS` table with the `EMPLOYEES` table, including all departments and employees even if they don't have matches.\n\n#### 5. CROSS JOIN\n\nA `CROSS JOIN` returns the Cartesian product of the two tables, meaning it returns all possible combinations of rows.\n\n**Syntax:**\n\n``` sql\nSELECT columns\nFROM table1\nCROSS JOIN table2;\n```\n\n**Example:**\n\nRetrieve all possible combinations of employees and departments.\n\n``` sql\nSELECT e.first_name, e.last_name, d.department_name\nFROM employees e\nCROSS JOIN departments d;\n```\n\nThis query combines each employee with every department, producing a large number of rows.\n\n#### 6. SELF JOIN\n\nA `SELF JOIN` is a regular join, but the table is joined with itself.\n\n**Syntax:**\n\n``` sql\nSELECT a.columns, b.columns\nFROM table a\nINNER JOIN table b ON a.common_column = b.common_column;\n```\n\n**Example:** Retrieve employees and their managers.\n\n``` sql\nSELECT e.first_name AS Employee, m.first_name AS Manager\nFROM employees e\nINNER JOIN employees m ON e.manager_id = m.employee_id;\n```\n\nThis query joins the `EMPLOYEES` table with itself to find each employee's manager.\n\n### Putting It All Together\n\nCombining multiple concepts into a single query using the HR schema:\n\n``` sql\nSELECT department_id, COUNT(employee_id) AS employee_count, AVG(salary) AS avg_salary \nFROM employees \nWHERE salary > 3000 \nGROUP BY department_id \nHAVING COUNT(employee_id) > 3 \nORDER BY avg_salary DESC \nLIMIT 5;\n```\n\nThis query:\n\n1.  **SELECT**: Retrieves `department_id`, the count of `employee_id` as `employee_count`, and the average `salary` as `avg_salary`.\n\n2.  **FROM**: Queries the `EMPLOYEES` table.\n\n3.  **WHERE**: Filters employees with a `salary` greater than 3000.\n\n4.  **GROUP BY**: Groups the result by `department_id`.\n\n5.  **HAVING**: Filters groups having more than 3 employees.\n\n6.  **ORDER BY**: Orders the result by `avg_salary` in descending order.\n\n7.  **FETCH FIRST**: Limits the result to the first 5 rows\n\nðŸ¹ Now you have learn the basic of SQL language, you might not realize that it actually follow a certain hierarchy pattern. ðŸ‘‡\n\n## SQL Statement Hierarchy\n\n1.  **SELECT**: Specifies the columns to retrieve.\n\n2.  **FROM**: Specifies the table(s) to query.\n\n3.  **WHERE**: Filters rows based on a condition.\n\n4.  **GROUP BY**: Groups rows sharing a property so that aggregate functions can be applied.\n\n5.  **HAVING**: Filters groups based on a condition.\n\n6.  **ORDER BY**: Sorts the result set.\n\n7.  **FETCH FIRST**: Limits the number of rows returned.\n\n### Graphic Representation\n\n### Example Query with Hierarchy\n\nSELECT: Specifies the columns to retrieve. FROM: Specifies the table(s) to query. WHERE: Filters rows based on a condition. GROUP BY: Groups rows sharing a property so that aggregate functions can be applied. HAVING: Filters groups based on a condition. ORDER BY: Sorts the result set. FETCH FIRST: Limits the number of rows returned.\n\nLet's illustrate this hierarchy with an example query:\n\n``` sql\nSELECT Country, COUNT(CustomerID) AS CustomerCount, AVG(LENGTH(CustomerName)) AS AvgCustomerNameLength\nFROM Customers\nGROUP BY Country\nHAVING COUNT(CustomerID) > 2\nORDER BY AvgCustomerNameLength DESC\nFETCH FIRST 5 ROWS ONLY;\n```\n\n**Explanation of the Query**:\n\n**`SELECT`**: Specifies the columns to retrieve: Country, the count of CustomerID as CustomerCount, and the average length of CustomerName as AvgCustomerNameLength.\n\n**`FROM`**: Indicates the Customers table to query.\n\n**`GROUP BY`:** Groups rows by the Country column.\n\n**`HAVING`**: Filters groups to include only those with more than 2 customers.\n\n**`ORDER BY`**: Sorts the results by AvgCustomerNameLength in descending order.\n\n**`FETCH FIRST`**: Limits the number of rows returned to the top 5.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}